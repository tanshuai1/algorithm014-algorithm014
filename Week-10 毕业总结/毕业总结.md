1、刷题方式：

		(1) 不要死磕、敢于放手、敢于死记硬背代码
		
		(2) 要学习高手的优秀代码
		
		(3) 最佳方式：5分钟想不出来，直接看题解，然后学习理解，多做几遍
		
		(4) 每个题不要只做一遍，要多做几遍 过遍数

2、数据结构：

		(1) 一维：数组、链表、栈、队列、双端队列、集合、映射
		
		(2) 二维：树、图、二叉搜索树、堆、并查集、字典树
		
		(3) 特殊：位运算、布隆过滤器、LRU Cache

3、算法：
	
		(1) If-else, switch --> 分支
		
		(2) for, while loop --> 迭代
	
		(3) 递归、分治、回溯
		
		(4) 搜索：深度优先搜索、广度优先搜索
		
		(5) 动态规划
		
		(6) 二分查找
		
		(7) 贪心
		
		(8) 数学、几何

4、跳表：只能用于元素有序的情况。在原始链表的基础上，添加多级索引。

在跳表中查询任意数据的时间复杂度为O(logn), 空间复杂度O(n)

跳表：升维思想 + 空间换时间

5、栈：先入后出，添加/删除复杂度为O(1)

6、队列：先入先出，添加/删除时间复杂度为O(1)

​	优先队列的实现机制：堆、二叉搜索树、树堆(Treap)

7、链表是特殊化的树，树是特殊化的图

8、二叉树的遍历：

		(1) 前序：根-左-右
		
		(2) 中序：左-根-右
	
		(3) 后序：左-右-根

9、二叉搜索树的中序遍历(左-根-右)是一个升序序列。

10、树的面试题解法一般都是递归(自重复性)。

11、递归的思维要点：

		(1) 不要人肉进行递归
		
		(2) 找到最近最简方法，将其拆解可重复解决的问题(重复子问题)
		
		(3) 数学归纳法思维

12、Heap: 可以迅速找到一堆数中的最大或者最小值的数据结构。

​	堆：通过完全二叉树来实现

13、堆一般通过“数组”来实现。

		(1) 索引为i的左孩子的索引是(2*i+1)
		
		(2) 索引为i的右孩子的索引是(2*i+2)
		
		(3) 索引为i的父节点的索引是floor((i-1)/2)

插入操作：

		(1) 新元素一律插入到堆的尾部
		
		(2) 依次向上调整整个堆的结构(一直到根即可)

删除堆顶操作：

		(1) 将堆尾元素替换到顶部(即对顶被替代删除掉)
		
		(2) 依次从根部向上调整整个堆的结构(一直到堆尾即可)

14、分治：分解为子问题，然后合并。

15、回溯：回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。

16、回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况:

		(1) 找到一个可能存在的正确的答案
		
		(2) 在尝试了所有可能的分步方法后宣告该问题没有答案
		
		在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算

17、贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有利)的选择，从而希望导致结果是全局最好或最优的算法。

18、贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

19、一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

20、问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。

21、贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

22、二分查找的前提：

		(1) 目标函数单调性(单调递增或者递减)
		
		(2) 存在上下界(bounded)
		
		(3) 能够通过索引访问(index accessible)

23、动态规划关键点：

		(1) 最优子结构：opt[n] = best_of(opt[n-1],opt[n-2],...)
		
		(2) 储存中间结构：opt[i]
		
		(3) 递推公式(美其名曰：状态转移方程或者D方程)

24、动态规划小结：

		(1) 打破自己的思维惯性，形成机器思维
		
		(2) 理解复杂逻辑的关键
		
		(3) 职业进阶的要点要领

25、字典树：即Trie数，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串(但不仅限于字符串)，所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

基本性质：

		(1)节点本身不存在完整单词
		(2)从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
	
		(3)每个结点的所有子结点路径代表的字符都不相同

Trie树的核心思想是空间换时间

利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的

26、高级搜索：剪枝、双向BFS、启发式搜索(A*)

27、红黑树是一种近似平衡的二叉搜索树，它能够确保任何一个结点的左右子树的高度差小于两倍。

红黑树满足以下条件：

		(1) 每个结点要么是红色，要么是黑色
		
		(2) 根节点是黑色
		
		(3) 每个叶节点是黑色的
		
		(4) 不能有相邻接的两个红色结点
		
		(5) 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

28、指定位置的位运算：

		(1) 将x最右边的n位清零：x & (~0 << n)
		
		(2) 获取x的第n位值(0或者1): (x >> n) & 1
		
		(3) 获取x的第n位的幂值：x & (1 << n)
		
		(4) 仅将第n位置为1： x | (1 << n)
		
		(5) 仅将第n位置为0： x & (~(1 << n))
	
		(6) 将x最高位至第n位(含)清零：x & ((1 << n) - 1)

实战位运算要点:

		(1) 判断奇偶：
		
				x % 2 == 1 --> (x & 1) == 1
				x % 2 == 0 --> (x & 1) == 0
	
		(2) x >> 1 --> x / 2
		
		(3) x = x & (x - 1) : 清零最低位的1
		
		(4) x & -x ==> 得到最低位的1
	
		(5) x & ~x => 0

29、正数的二进制补码：就是原码

负数的二进制补码：将这个负整数的绝对值求反加1

30、布隆过滤器：一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。

布隆过滤器：

		(1) 优点：空间效率和查询时间都远远超过一般的算法
		
		(2) 缺点：有一定的误识别率和删除困难

31、LRU Cache： 哈希表 + 双向链表

		(1) 查询：O(1)
		
		(2) 修改、更新：O(1)

32、排序算法：

		(1) 交换排序：冒泡排序、快速排序
		
		(2) 插入排序：简单插入排序、希尔排序
		
		(3) 选择排序：简单选择排序、堆排序
		
		(4) 归并排序：二路归并排序、多路归并排序
		
		(5) 非比较类排序：计数排序、桶排序、基数排序

选择排序：每次选择最小值，然后放到待排序序列的起始位置

插入排序：从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

冒泡排序：嵌套循环，每次查看相邻的元素。如果逆序，则交换

快速排序：数组取标杆pivot，将小元素放在pivot的左边，大元素放在右边，然后依次对左边和右边的子数组继续快排；以达到整个序列有序

归并排序：

	(1) 把长度为n个输入序列分成两个长度为n/2的子序列
	
	(2) 对这两个子序列分别采用归并排序
	
	(3) 将两个排序好的子序列合并成一个最终的排序序列

归并和快排具有相似性：

	(1) 归并：先排序左右子数组，然后合并两个有序子数组
	
	(2) 快排：先调配出左右子数组，然后对于左右子数组进行排序

堆排序：

	(1) 数组元素依次建立小顶堆
	
	(2) 依次取堆顶元素，并删除

计数排序：计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转换为键存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。

桶排序：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或者是以递归方式继续使用桶排序进行排列)。

基数排序：按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。

33、字符串匹配算法：Rabin-Karp算法、KMP算法